1.Given two tables below, write a query to display the comparison result (higher/lower/same) 
of the average salary of employees in a department to the companyâ€™s average salary.
-- Table: salary
-- | id | employee_id | amount | pay_date   |
-- |----|-------------|--------|------------|
-- | 1  | 1           | 9000   | 2017-03-31 |
-- | 2  | 2           | 6000   | 2017-03-31 |
-- | 3  | 3           | 10000  | 2017-03-31 |
-- | 4  | 1           | 7000   | 2017-02-28 |
-- | 5  | 2           | 6000   | 2017-02-28 |
-- | 6  | 3           | 8000   | 2017-02-28 |
 

-- The employee_id column refers to the employee_id in the following table employee.
 

-- | employee_id | department_id |
-- |-------------|---------------|
-- | 1           | 1             |
-- | 2           | 2             |
-- | 3           | 2             |
 

-- So for the sample data above, the result is:
 

-- | pay_month | department_id | comparison  |
-- |-----------|---------------|-------------|
-- | 2017-03   | 1             | higher      |
-- | 2017-03   | 2             | lower       |
-- | 2017-02   | 1             | same        |
-- | 2017-02   | 2             | same        |

_________________________________________________________________________________________
solution:
select 
    pay_month,
    department_id, 
    case when dept_avg > comp_avg then 'higher' when dept_avg < comp_avg then 'lower' else 'same' end comparison
from (
        select  date_format(b.pay_date, '%Y-%m') pay_month, a.department_id, avg(b.amount) dept_avg,  d.comp_avg
        from employe a 
        inner join salary b
            on (a.employee_id = b.employee_id) 
        inner join (select date_format(c.pay_date, '%Y-%m') pay_month, avg(c.amount) comp_avg 
                    from salary c 
                    group by date_format(c.pay_date, '%Y-%m')) d 
            on ( date_format(b.pay_date, '%Y-%m') = d.pay_month)
group by date_format(b.pay_date, '%Y-%m'), department_id, d.comp_avg) final;
				
								(or)

select department_salary.pay_month, department_id,
    case
        when department_avg > company_avg then 'higher'
        when department_avg < company_avg then 'lower'
        else 'same'
    end as comparison
    from (
        select department_id, avg(amount) as department_avg, date_format(pay_date, '%Y-%m') as pay_month
            from salary join employe on salary.employee_id = employe.employee_id
            group by department_id, pay_month
    ) as department_salary
    join (
        select avg(amount) as company_avg, date_format(pay_date, '%Y-%m') as pay_month
            from salary group by date_format(pay_date, '%Y-%m')
    ) as company_salary
    on department_salary.pay_month = company_salary.pay_month;
________________________________________________________________________________________

2.-- A "quite" student is the one who took at least one exam and didn't score
neither the high score nor the low score.

-- Write an SQL query to report the students (student_id, student_name) 
being "quiet" in ALL exams.

-- Don't return the student who has never taken any exam. Return the result 
table ordered by student_id.

-- The query result format is in the following example.

-- Student table:
-- +-------------+---------------+
-- | student_id  | student_name  |
-- +-------------+---------------+
-- | 1           | Daniel        |
-- | 2           | Jade          |
-- | 3           | Stella        |
-- | 4           | Jonathan      |
-- | 5           | Will          |
-- +-------------+---------------+

-- Exam table:
-- +------------+--------------+-----------+
-- | exam_id    | student_id   | score     |
-- +------------+--------------+-----------+
-- | 10         |     1        |    70     |
-- | 10         |     2        |    80     |
-- | 10         |     3        |    90     |
-- | 20         |     1        |    80     |
-- | 30         |     1        |    70     |
-- | 30         |     3        |    80     |
-- | 30         |     4        |    90     |
-- | 40         |     1        |    60     |
-- | 40         |     2        |    70     |
-- | 40         |     4        |    80     |
-- +------------+--------------+-----------+

-- Result table:
-- +-------------+---------------+
-- | student_id  | student_name  |
-- +-------------+---------------+
-- | 2           | Jade          |
-- +-------------+---------------+

__________________________________________________________________________________
solution:

select 
   student.*
from exam 
inner join student on student.student_id=exam.student_id
group by student_id,student_name 
having max(score) not in (select max(score) from exam) 
   and min(score) not in (select min(score) from exam);

                                 (or)
with high_low as
(select max(score) as high_score, min(score) as low_score
from Exam) 
select student.student_id, student_name
from (
  select exam.student_id 
   from exam
   group by exam.student_id
   having max(score) <> (select high_score from high_low)
      and min(score) <> (select low_score from high_low)) x
inner join student on student.student_id=x.student_id;

__________________________________________________________________________________
 
3. X city built a new stadium, each day many people visit it and 
the stats are saved as these columns: id, visit_date, people

-- write a query to display the records which have 3 or 
more consecutive rows and the amount of people more than 100(inclusive).

-- For example, the table stadium:
-- +------+------------+-----------+
-- | id   | visit_date | people    |
-- +------+------------+-----------+
-- | 1    | 2017-01-01 | 10        |
-- | 2    | 2017-01-02 | 109       |
-- | 3    | 2017-01-03 | 150       |
-- | 4    | 2017-01-04 | 99        |
-- | 5    | 2017-01-05 | 145       |
-- | 6    | 2017-01-06 | 1455      |
-- | 7    | 2017-01-07 | 199       |
-- | 8    | 2017-01-08 | 188       |
-- +------+------------+-----------+
-- For the sample data above, the output is:

-- +------+------------+-----------+
-- | id   | visit_date | people    |
-- +------+------------+-----------+
-- | 5    | 2017-01-05 | 145       |
-- | 6    | 2017-01-06 | 1455      |
-- | 7    | 2017-01-07 | 199       |
-- | 8    | 2017-01-08 | 188       |
-- +------+------------+-----------+
-- Note:
-- Each day only have one row record, and the dates are increasing with id increasing.

____________________________________________________________________________________________________________

output:

SELECT DISTINCT SS.*
FROM STADIUM SS
INNER JOIN
(SELECT S1.ID
    FROM STADIUM S1
    WHERE 3 = (
    SELECT COUNT(1)
    FROM STADIUM S2
    WHERE (S2.ID=S1.ID OR S2.ID=S1.ID+1 OR S2.ID=S1.ID+2)
    AND S2.PEOPLE >= 100
    )) AS SS2
    ON SS.ID>=SS2.ID AND SS.ID<SS2.ID+3 order by id;

_____________________________________________________________________________________________________________


4.
-- Write an SQL query to find how many users visited the bank and didn't do any transactions, 
how many visited the bank and did one transaction and so on.

-- The query result format is in the following example:

-- Visits table:
-- +---------+------------+
-- | user_id | visit_date |
-- +---------+------------+
-- | 1       | 2020-01-01 |
-- | 2       | 2020-01-02 |
-- | 12      | 2020-01-01 |
-- | 19      | 2020-01-03 |
-- | 1       | 2020-01-02 |
-- | 2       | 2020-01-03 |
-- | 1       | 2020-01-04 |
-- | 7       | 2020-01-11 |
-- | 9       | 2020-01-25 |
-- | 8       | 2020-01-28 |
-- +---------+------------+
-- Transactions table:
-- +---------+------------------+--------+
-- | user_id | transaction_date | amount |
-- +---------+------------------+--------+
-- | 1       | 2020-01-02       | 120    |
-- | 2       | 2020-01-03       | 22     |
-- | 7       | 2020-01-11       | 232    |
-- | 1       | 2020-01-04       | 7      |
-- | 9       | 2020-01-25       | 33     |
-- | 9       | 2020-01-25       | 66     |
-- | 8       | 2020-01-28       | 1      |
-- | 9       | 2020-01-25       | 99     |
-- +---------+------------------+--------+
-- Result table:
-- +--------------------+--------------+
-- | transactions_count | visits_count |
-- +--------------------+--------------+
-- | 0                  | 4            |
-- | 1                  | 5            |
-- | 2                  | 0            |
-- | 3                  | 1            |
-- +--------------------+--------------+
-- * For transactions_count = 0, The visits (1, "2020-01-01"), (2, "2020-01-02"), 
(12, "2020-01-01") and (19, "2020-01-03") did no transactions so visits_count = 4.
-- * For transactions_count = 1, The visits (2, "2020-01-03"), (7, "2020-01-11"), 
(8, "2020-01-28"), (1, "2020-01-02") and (1, "2020-01-04") did one transaction so visits_count = 5.
-- * For transactions_count = 2, No customers visited the bank and 
did two transactions so visits_count = 0.
-- * For transactions_count = 3, The visit (9, "2020-01-25") 
did three transactions so visits_count = 1.
-- * For transactions_count >= 4, No customers visited the bank and
did more than three transactions so we will stop at transactions_count = 3

 


select t5.transactions_count, ifnull(t4.count_sum, 0) as visits_count from (
    select @num := @num + 1 as transactions_count from Transactions, (select @num := 0) t2
        where @num < (
            select max(t1.count) as max_visit from (
                select user_id, transaction_date, count(*) as count from Transactions
                    group by user_id, transaction_date
            ) t1
        )
) t5
left join (
    select t3.count, count(*) as count_sum from (
        select user_id, transaction_date, count(*) as count from Transactions
            group by user_id, transaction_date
    ) t3 group by t3.count
) t4 on t4.count = t5.transactions_count
union all
select 0 as transactions_count, count(*) as visits_count from (
    select user_id, transaction_date, sum(amount) as amount from Transactions
        group by user_id, transaction_date
) t6
    right join Visits v
    on t6.user_id = v.user_id
    and t6.transaction_date = v.visit_date
    where t6.amount is null
    order by transactions_count asc;









WITH RECURSIVE t1 AS(
					SELECT visit_date, 
							COALESCE(num_visits,0) as num_visits, 
							COALESCE(num_trans,0) as num_trans 
					FROM ((
							SELECT visit_date, user_id, COUNT(*) as num_visits 
                            FROM visits 
                            GROUP BY 1, 2) AS a 
                            LEFT JOIN 
							(
                            SELECT transaction_date, user_id, count(*) as num_trans 
                            FROM transactions 
                            GROUP BY 1, 2) AS b
                            ON a.visit_date = b.transaction_date and a.user_id = b.user_id)
						 ),
				t2 AS ( 
						SELECT MAX(num_trans) as trans 
                        FROM t1 
                        UNION ALL 
                        SELECT trans-1  FROM t2 
                        WHERE trans >= 1)
SELECT trans as transactions_count,  COALESCE(visits_count,0) as visits_count 
FROM t2 LEFT JOIN(
			    SELECT num_trans as transactions_count, COALESCE(COUNT(*),0) as visits_count
                FROM t1  GROUP BY 1 ORDER BY 1) AS a 
                ON a.transactions_count = t2.trans ORDER BY 1;






5.

-- A system is running one task every day. Every task is independent of the previous tasks. 
The tasks can fail or succeed.

-- Write an SQL query to generate a report of period_state for each continuous interval of
days in the period from 2019-01-01 to 2019-12-31.

-- period_state is 'failed' if tasks in this interval failed or 'succeeded' if tasks 
in this interval succeeded. Interval of days are retrieved as start_date and end_date.

-- Order result by start_date.

-- The query result format is in the following example:

-- Failed table:
-- +-------------------+
-- | fail_date         |
-- +-------------------+
-- | 2018-12-28        |
-- | 2018-12-29        |
-- | 2019-01-04        |
-- | 2019-01-05        |
-- +-------------------+

-- Succeeded table:
-- +-------------------+
-- | success_date      |
-- +-------------------+
-- | 2018-12-30        |
-- | 2018-12-31        |
-- | 2019-01-01        |
-- | 2019-01-02        |
-- | 2019-01-03        |
-- | 2019-01-06        |
-- +-------------------+


-- Result table:
-- +--------------+--------------+--------------+
-- | period_state | start_date   | end_date     |
-- +--------------+--------------+--------------+
-- | succeeded    | 2019-01-01   | 2019-01-03   |
-- | failed       | 2019-01-04   | 2019-01-05   |
-- | succeeded    | 2019-01-06   | 2019-01-06   |
-- +--------------+--------------+--------------+

-- The report ignored the system state in 2018 as we care about the system in the
period 2019-01-01 to 2019-12-31.
-- From 2019-01-01 to 2019-01-03 all tasks succeeded and the system state was "succeeded".
-- From 2019-01-04 to 2019-01-05 all tasks failed and system state was "failed".
-- From 2019-01-06 to 2019-01-06 all tasks succeeded and system state was "succeeded".








select 'succeeded' as period_state, start_date, min(end_date) as end_date from (
    select success_date as start_date from Succeeded
        where year(success_date) = 2019 and date_sub(success_date, interval 1 day) not in (
            select success_date from Succeeded where year(success_date) = 2019
        )
    ) ss join (
    select success_date as end_date from Succeeded
        where year(success_date) = 2019 and date_add(success_date, interval 1 day) not in (
            select success_date from Succeeded where year(success_date) = 2019
        )
    ) se
    on start_date <= end_date group by start_date
    union all
select 'failed' as period_state, start_date, min(end_date) as end_date from (
    select fail_date as start_date from Failed
        where year(fail_date) = 2019 and date_sub(fail_date, interval 1 day) not in (
            select fail_date from Failed where year(fail_date) = 2019
        )
    ) fs join (
    select fail_date as end_date from Failed
        where year(fail_date) = 2019 and date_add(fail_date, interval 1 day) not in (
            select fail_date from Failed where year(fail_date) = 2019
        )
    ) fe
    on start_date <= end_date group by start_date
    order by start_date;



